<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accelerometer Spin Counter</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Body and Container Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2C3E50; /* Deep Indigo - calming dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #ECF0F1; /* Light text for dark background */
        }
        .container {
            background-color: #34495E; /* Slightly lighter dark shade */
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.5), 0 6px 12px -3px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        h1 {
            color: #ECF0F1;
            margin-bottom: 24px;
            font-size: 2.25rem; /* Larger heading */
        }

        /* Data Display Styles */
        .data-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-top: 24px;
            text-align: left;
        }
        .data-item {
            background-color: #49637A; /* Darker blue-grey */
            padding: 12px;
            border-radius: 8px;
            font-size: 0.95rem;
            color: #BDC3C7; /* Lighter grey text */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .data-item strong {
            color: #ECF0F1;
        }

        /* Button Group Styles */
        .button-group {
            margin-top: 32px;
            display: flex;
            gap: 16px;
            justify-content: center;
        }
        .btn {
            padding: 12px 24px;
            border-radius: 9999px; /* Fully rounded */
            font-weight: 700; /* Bolder font */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            min-width: 150px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background-image: linear-gradient(145deg, var(--start-color) 0%, var(--end-color) 100%);
            border: none;
            color: white;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        /* Button specific colors */
        .btn-start {
            --start-color: #27AE60; /* Emerald Green */
            --end-color: #2ECC71; /* Nephritis Green */
        }
        .btn-start:hover:not(:disabled) {
            --start-color: #2ECC71;
            --end-color: #27AE60;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px -3px rgba(0, 0, 0, 0.4);
        }
        .btn-stop {
            --start-color: #E74C3C; /* Alizarin Red */
            --end-color: #C0392B; /* Pomegranate Red */
        }
        .btn-stop:hover:not(:disabled) {
            --start-color: #C0392B;
            --end-color: #E74C3C;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px -3px rgba(0, 0, 0, 0.4);
        }

        /* Message Box Styles */
        .message {
            margin-top: 24px;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.95rem;
            text-align: left;
            display: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .message.show {
            display: block;
        }
        .message.error {
            background-color: #C0392B; /* Pomegranate Red */
            border: 1px solid #E74C3C;
            color: #ECF0F1;
        }
        .message.warning {
            background-color: #F39C12; /* Orange */
            border: 1px solid #E67E22;
            color: #ECF0F1;
        }
        .message.info {
            background-color: #2980B9; /* Belize Hole Blue */
            border: 1px solid #3498DB;
            color: #ECF0F1;
        }

        /* Graph Container Styles */
        .graph-container {
            margin-top: 32px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }
        .graph-item {
            background-color: #34495E;
            border: 1px solid #49637A;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .graph-item h3 {
            font-weight: 600;
            margin-bottom: 10px;
            color: #ECF0F1;
            font-size: 1.2rem;
        }
        canvas {
            width: 100%;
            height: 150px; /* Fixed height for consistency */
            background-color: #2C3E50; /* Even darker background for canvas */
            border: 1px solid #1abc9c; /* Slight border highlight */
            border-radius: 4px;
        }

        /* Captured Spin Graphs Styles */
        .captured-spins-container {
            margin-top: 40px;
            border-top: 1px dashed #7F8C8D; /* Ash Gray */
            padding-top: 30px;
            text-align: center;
            color: #ECF0F1;
        }
        .captured-spins-container h2 {
            font-size: 1.75rem;
            font-weight: bold;
            color: #ECF0F1;
            margin-bottom: 24px;
        }
        .captured-spin-item {
            background-color: #49637A;
            border: 1px solid #7F8C8D;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: left;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .captured-spin-item h4 {
            font-weight: 600;
            color: #ECF0F1;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        .captured-spin-item canvas {
            width: 100%;
            height: 100px; /* Smaller height for captured snippets */
            background-color: #2C3E50;
            border: 1px solid #7F8C8D;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold">SpinSense: Motion Analyzer</h1>

        <div class="button-group">
            <button id="startButton" class="btn btn-start">Start Monitoring</button>
            <button id="stopButton" class="btn btn-stop" disabled>Stop Monitoring</button>
        </div>

        <div id="messageBox" class="message"></div>

        <div class="data-display">
            <!-- Accelerometer Data -->
            <div class="data-item"><strong>Accel X:</strong> <span id="accelX">0.00</span> m/s²</div>
            <div class="data-item"><strong>Accel Y:</strong> <span id="accelY">0.00</span> m/s²</div>
            <div class="data-item"><strong>Accel Z:</strong> <span id="accelZ">0.00</span> m/s²</div>
            <div class="data-item"></div> <!-- Spacer -->

            <!-- Spin Counts -->
            <div class="data-item"><strong>Yaw (Z-axis) Spins:</strong> <span id="spinZ">0</span></div>
            <div class="data-item"><strong>Pitch (X-axis) Spins:</b> <span id="spinX">0</span></div>
            <div class="data-item"><strong>Roll (Y-axis) Spins:</strong> <span id="spinY">0</span></div>
            <div class="data-item"><strong>Total Spins:</strong> <span id="spinTotal">0</span></div>
        </div>

        <div class="graph-container">
            <div class="graph-item">
                <h3>Yaw (Z-axis) - Alpha</h3>
                <canvas id="yawGraph"></canvas>
            </div>
            <div class="graph-item">
                <h3>Pitch (X-axis) - Beta</h3>
                <canvas id="pitchGraph"></canvas>
            </div>
            <div class="graph-item">
                <h3>Roll (Y-axis) - Gamma</h3>
                <canvas id="rollGraph"></canvas>
            </div>
        </div>

        <!-- Container for captured spin graphs -->
        <div id="capturedSpinsContainer" class="captured-spins-container" style="display: none;">
            <h2>Captured Spins Timeline</h2>
            <!-- Captured spin graphs will be dynamically added here -->
        </div>
    </div>

    <!-- Web Worker Script (simulated file for Canvas environment) -->
    <script id="spinWorkerScript" type="text/plain">
        // spinWorker.js
        let lastAlpha = null;
        let lastBeta = null;
        let lastGamma = null;

        let cumulativeAlphaRotation = 0;
        let cumulativeBetaRotation = 0;
        let cumulativeGammaRotation = 0;

        let spinZCount = 0;
        let spinXCount = 0;
        let spinYCount = 0;
        let spinTotalCount = 0;

        const MAX_GRAPH_POINTS = 100; // Keep in sync with main thread
        let historyAlpha = [];
        let historyBeta = [];
        let historyGamma = [];

        /**
         * Calculates change in angle and updates cumulative rotation and spin count.
         * Handles the 0-360 degree wrap-around.
         * @param {number} currentAngle Current angle (alpha, beta, or gamma).
         * @param {number} lastAngle Previous angle.
         * @param {number} cumulativeRotation Current cumulative rotation.
         * @param {number} spinCount Current spin count.
         * @returns {object} An object containing updated cumulativeRotation and spinCount, and a boolean indicating if a new spin was detected.
         */
        function updateSpinCount(currentAngle, lastAngle, cumulativeRotation, spinCount) {
            let newSpinDetected = false;
            if (lastAngle === null) {
                return { cumulativeRotation: 0, spinCount: 0, newSpinDetected: false };
            }

            let delta = currentAngle - lastAngle;

            // Handle wrap-around for angles (e.g., 350 -> 10 should be +20, not -340)
            if (delta > 180) {
                delta -= 360;
            } else if (delta < -180) {
                delta += 360;
            }

            cumulativeRotation += delta;

            // Check for full 360-degree rotations
            while (cumulativeRotation >= 360) {
                spinCount++;
                cumulativeRotation -= 360;
                newSpinDetected = true;
            }
            while (cumulativeRotation <= -360) {
                spinCount++;
                cumulativeRotation += 360;
                newSpinDetected = true;
            }

            return { cumulativeRotation, spinCount, newSpinDetected };
        }

        /**
         * Handles DeviceMotionEvent (accelerometer data).
         * @param {DeviceMotionEvent} event
         */
        function handleWorkerDeviceMotion(event) {
            self.postMessage({
                type: 'accelData',
                x: event.accelerationIncludingGravity?.x,
                y: event.accelerationIncludingGravity?.y,
                z: event.accelerationIncludingGravity?.z
            });
        }

        /**
         * Handles DeviceOrientationEvent (alpha, beta, gamma for spins).
         * @param {DeviceOrientationEvent} event
         */
        function handleWorkerDeviceOrientation(event) {
            const alpha = event.alpha; // Z-axis (yaw)
            const beta = event.beta;   // X-axis (pitch)
            const gamma = event.gamma; // Y-axis (roll)

            if (alpha !== null && beta !== null && gamma !== null) {
                // Update history for graphing
                historyAlpha.push(alpha);
                historyBeta.push(beta);
                historyGamma.push(gamma);

                if (historyAlpha.length > MAX_GRAPH_POINTS) historyAlpha.shift();
                if (historyBeta.length > MAX_GRAPH_POINTS) historyBeta.shift();
                if (historyGamma.length > MAX_GRAPH_POINTS) historyGamma.shift();

                let spinType = null;

                // Update Z-axis (Yaw) spins
                const resultZ = updateSpinCount(alpha, lastAlpha, cumulativeAlphaRotation, spinZCount);
                if (resultZ.newSpinDetected) {
                    spinType = 'Yaw';
                    self.postMessage({ type: 'spinDetected', axis: 'Yaw', count: resultZ.spinCount, data: [...historyAlpha] });
                    spinTotalCount++;
                }
                cumulativeAlphaRotation = resultZ.cumulativeRotation;
                spinZCount = resultZ.spinCount;
                lastAlpha = alpha;

                // Update X-axis (Pitch) spins
                const resultX = updateSpinCount(beta, lastBeta, cumulativeBetaRotation, spinXCount);
                if (resultX.newSpinDetected) {
                    spinType = 'Pitch';
                    self.postMessage({ type: 'spinDetected', axis: 'Pitch', count: resultX.spinCount, data: [...historyBeta] });
                    spinTotalCount++;
                }
                cumulativeBetaRotation = resultX.cumulativeRotation;
                spinXCount = resultX.spinCount;
                lastBeta = beta;

                // Update Y-axis (Roll) spins
                const resultY = updateSpinCount(gamma, lastGamma, cumulativeGammaRotation, spinYCount);
                if (resultY.newSpinDetected) {
                    spinType = 'Roll';
                    self.postMessage({ type: 'spinDetected', axis: 'Roll', count: resultY.spinCount, data: [...historyGamma] });
                    spinTotalCount++;
                }
                cumulativeGammaRotation = resultY.cumulativeRotation;
                spinYCount = resultY.spinCount;
                lastGamma = gamma;

                // Post all real-time data back to main thread
                self.postMessage({
                    type: 'sensorData',
                    alpha: alpha,
                    beta: beta,
                    gamma: gamma,
                    spinZ: spinZCount,
                    spinX: spinXCount,
                    spinY: spinYCount,
                    spinTotal: spinTotalCount,
                    historyAlpha: [...historyAlpha],
                    historyBeta: [...historyBeta],
                    historyGamma: [...historyGamma]
                });

            }
        }

        // Listen for messages from the main thread
        self.onmessage = (event) => {
            const command = event.data.command;

            if (command === 'start') {
                // Reset worker state
                lastAlpha = null;
                lastBeta = null;
                lastGamma = null;
                cumulativeAlphaRotation = 0;
                cumulativeBetaRotation = 0;
                cumulativeGammaRotation = 0;
                spinZCount = 0;
                spinXCount = 0;
                spinYCount = 0;
                spinTotalCount = 0;
                historyAlpha = [];
                historyBeta = [];
                historyGamma = [];

                self.addEventListener('deviceorientation', handleWorkerDeviceOrientation);
                self.addEventListener('devicemotion', handleWorkerDeviceMotion);
                self.postMessage({ type: 'status', message: 'Worker started monitoring sensors.' });
            } else if (command === 'stop') {
                self.removeEventListener('deviceorientation', handleWorkerDeviceOrientation);
                self.removeEventListener('devicemotion', handleWorkerDeviceMotion);
                self.postMessage({ type: 'status', message: 'Worker stopped monitoring sensors.' });
            }
        };

        // Initial message to confirm worker started
        self.postMessage({ type: 'status', message: 'SpinWorker initialized.' });
    </script>

    <script>
        // --- Main Thread Script ---

        // DOM Elements
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const messageBox = document.getElementById('messageBox');

        const accelXSpan = document.getElementById('accelX');
        const accelYSpan = document.getElementById('accelY');
        const accelZSpan = document.getElementById('accelZ');

        const spinZSpan = document.getElementById('spinZ');
        const spinXSpan = document.getElementById('spinX');
        const spinYSpan = document.getElementById('spinY');
        const spinTotalSpan = document.getElementById('spinTotal');

        const yawGraphCanvas = document.getElementById('yawGraph');
        const pitchGraphCanvas = document.getElementById('pitchGraph');
        const rollGraphCanvas = document.getElementById('rollGraph');

        const yawGraphCtx = yawGraphCanvas.getContext('2d');
        const pitchGraphCtx = pitchGraphCanvas.getContext('2d');
        const rollGraphCtx = rollGraphCanvas.getContext('2d');

        const capturedSpinsContainer = document.getElementById('capturedSpinsContainer');

        // State variables for monitoring
        let isMonitoring = false;

        // History for graphing (now updated by worker messages)
        const MAX_GRAPH_POINTS = 100; // Must match worker's MAX_GRAPH_POINTS
        let historyAlpha = [];
        let historyBeta = [];
        let historyGamma = [];

        // Store captured spin data
        let capturedSpins = [];

        // Audio Context for sound feedback
        let audioCtx;
        function playSpinSound() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sine'; // Sine wave for a clean tone
            oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A note
            gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); // Max volume

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1); // Play for 0.1 seconds
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1); // Fade out
        }

        // --- Web Worker Setup ---
        // Create a Blob URL from the inline script to simulate a separate worker file
        const workerScriptElement = document.getElementById('spinWorkerScript');
        const workerCode = workerScriptElement.textContent;
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerBlobURL = URL.createObjectURL(workerBlob);
        const spinWorker = new Worker(workerBlobURL);

        // Listen for messages from the Web Worker
        spinWorker.onmessage = (event) => {
            const data = event.data;
            // console.log('Message from worker:', data.type, data); // Debug worker messages

            if (data.type === 'status') {
                console.log(`Worker Status: ${data.message}`);
            } else if (data.type === 'accelData') {
                // Update raw accelerometer display
                accelXSpan.textContent = data.x !== undefined && data.x !== null ? data.x.toFixed(2) : '0.00';
                accelYSpan.textContent = data.y !== undefined && data.y !== null ? data.y.toFixed(2) : '0.00';
                accelZSpan.textContent = data.z !== undefined && data.z !== null ? data.z.toFixed(2) : '0.00';
            } else if (data.type === 'sensorData') {
                // Update real-time spin counts and live graphs
                spinZSpan.textContent = data.spinZ;
                spinXSpan.textContent = data.spinX;
                spinYSpan.textContent = data.spinY;
                spinTotalSpan.textContent = data.spinTotal;

                historyAlpha = data.historyAlpha;
                historyBeta = data.historyBeta;
                historyGamma = data.historyGamma;

                // Draw live graphs (no animation here)
                drawGraph(yawGraphCtx, historyAlpha, 0, 360, '#27AE60'); // Emerald Green
                drawGraph(pitchGraphCtx, historyBeta, -90, 90, '#3498DB'); // Peter River Blue
                drawGraph(rollGraphCtx, historyGamma, -90, 90, '#F1C40F'); // Sunflower Yellow
            } else if (data.type === 'spinDetected') {
                console.log(`Spin Detected on Main Thread: ${data.axis} (Count: ${data.count})`);
                capturedSpins.push({
                    type: data.axis,
                    data: data.data, // The snapshot of history at the time of spin
                    spinCount: data.count,
                    timestamp: new Date().toLocaleTimeString() // Add timestamp
                });

                // Trigger sensory feedback
                playSpinSound();
                if (navigator.vibrate) {
                    navigator.vibrate(100); // Vibrate for 100ms
                }
            }
        };

        // --- Utility Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} msg The message to display.
         * @param {string} type Optional. 'error', 'warning', 'info' for styling.
         */
        function showMessage(msg, type = 'info') {
            console.log(`Message (${type}): ${msg}`); // Log messages to console
            messageBox.textContent = msg;
            messageBox.className = `message show ${type}`; // Reset and add new classes
        }

        /**
         * Hides the message box.
         */
        function hideMessage() {
            messageBox.classList.remove('show', 'error', 'warning', 'info');
            messageBox.textContent = '';
        }

        /**
         * Draws a line graph on the given canvas context.
         * @param {CanvasRenderingContext2D} ctx The canvas 2D rendering context.
         * @param {Array<number>} data The array of angle values to plot.
         * @param {number} minValue The minimum expected value for the angle (e.g., 0 or -180).
         * @param {number} maxValue The maximum expected value for the angle (e.g., 360 or 180).
         * @param {string} lineColor The color of the graph line.
         * @param {number} [progress=1] Optional. Animation progress from 0 to 1. Only draws up to this percentage of data.
         */
        function drawGraph(ctx, data, minValue, maxValue, lineColor = '#4A90E2', progress = 1) {
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw background grid lines (optional, for better readability)
            ctx.strokeStyle = '#7F8C8D'; /* Ash Gray */
            ctx.lineWidth = 0.5;

            // Draw horizontal lines for typical range boundaries (e.g., 0, 90, 180, etc.)
            const drawHorizontalLine = (value) => {
                const y = height - ((value - minValue) * (height / (maxValue - minValue)));
                if (y >= 0 && y <= height) { // Ensure line is within canvas bounds
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            };
            drawHorizontalLine(0); // Zero line
            if (minValue <= 90 && maxValue >= 90) drawHorizontalLine(90);
            if (minValue <= -90 && maxValue >= -90) drawHorizontalLine(-90);
            if (minValue <= 180 && maxValue >= 180) drawHorizontalLine(180);


            // Draw the graph line
            ctx.beginPath();
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;

            const range = maxValue - minValue;
            const scaleY = height / range;
            const numPointsToDraw = Math.ceil(data.length * progress);
            const scaleX = width / MAX_GRAPH_POINTS; // Use MAX_GRAPH_POINTS for live graph consistent spacing

            if (data.length > 0) {
                const y = height - ((data[0] - minValue) * scaleY);
                ctx.moveTo(0, y);
            }

            for (let i = 0; i < numPointsToDraw; i++) {
                const x = i * scaleX;
                const y = height - ((data[i] - minValue) * scaleY);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }


        /**
         * Requests device orientation permissions if necessary (for iOS 13+).
         * Then sends start command to worker.
         */
        async function requestPermissionsAndStart() {
            startButton.disabled = true; // Disable to prevent multiple clicks
            hideMessage(); // Clear previous messages
            capturedSpinsContainer.style.display = 'none'; // Hide captured spins section
            capturedSpinsContainer.innerHTML = '<h2>Captured Spins Timeline</h2>'; // Clear previous captured graphs

            // Check if DeviceOrientationEvent is supported at all
            if (!window.DeviceOrientationEvent) {
                showMessage('Device Orientation Event (for spin counting) not supported on this browser/device.', 'error');
                startButton.disabled = false;
                return;
            }

            // Check if DeviceMotionEvent is supported (for raw accel data)
            if (!window.DeviceMotionEvent) {
                showMessage('Device Motion Event (for raw accelerometer data) not fully supported. Spin counting may still work.', 'warning');
            }


            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires explicit permission request
                try {
                    showMessage('Requesting device motion permissions...', 'info');
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        showMessage('Device motion permission granted! Monitoring starting...', 'info');
                        startMonitoringListeners();
                    } else {
                        showMessage('Permission to access device motion sensors was denied. Cannot start monitoring.', 'error');
                        startButton.disabled = false;
                        stopButton.disabled = true;
                    }
                } catch (error) {
                    showMessage(`Error requesting device motion permission: ${error.message}. Please check your browser settings.`, 'error');
                    console.error("Permission request error:", error);
                    startButton.disabled = false;
                    stopButton.disabled = true;
                }
            } else {
                // For browsers that don't require explicit permission or older iOS versions
                showMessage('Device motion permission not explicitly required or already granted. Monitoring starting...', 'info');
                startMonitoringListeners();
            }
        }

        /**
         * Sends start command to worker and updates UI state.
         */
        function startMonitoringListeners() {
            if (isMonitoring) return;

            // Reset all counts and history on main thread (worker also resets its own)
            historyAlpha = [];
            historyBeta = [];
            historyGamma = [];
            capturedSpins = []; // Clear captured spins from previous session

            // Reset UI counts immediately
            spinZSpan.textContent = '0';
            spinXSpan.textContent = '0';
            spinYSpan.textContent = '0';
            spinTotalSpan.textContent = '0';
            accelXSpan.textContent = '0.00';
            accelYSpan.textContent = '0.00';
            accelZSpan.textContent = '0.00';

            // Clear live graphs
            yawGraphCtx.clearRect(0,0, yawGraphCanvas.width, yawGraphCanvas.height);
            pitchGraphCtx.clearRect(0,0, pitchGraphCanvas.width, pitchGraphCanvas.height);
            rollGraphCtx.clearRect(0,0, rollGraphCanvas.width, rollGraphCanvas.height);


            // Send start command to worker
            spinWorker.postMessage({ command: 'start' });

            isMonitoring = true;
            startButton.disabled = true;
            stopButton.disabled = false;
        }


        /**
         * Stops monitoring accelerometer and orientation data and displays captured spins.
         */
        function stopMonitoring() {
            if (!isMonitoring) return;

            // Send stop command to worker
            spinWorker.postMessage({ command: 'stop' });

            isMonitoring = false;
            startButton.disabled = false;
            stopButton.disabled = true;
            showMessage('Monitoring stopped.', 'info');

            // Clear live graphs
            yawGraphCtx.clearRect(0, 0, yawGraphCanvas.width, yawGraphCanvas.height);
            pitchGraphCtx.clearRect(0, 0, pitchGraphCanvas.width, pitchGraphCanvas.height);
            rollGraphCtx.clearRect(0, 0, rollGraphCanvas.width, rollGraphCanvas.height);

            console.log(`Total captured spins: ${capturedSpins.length}`); // Log captured spins count

            // Display captured spins
            if (capturedSpins.length > 0) {
                capturedSpinsContainer.style.display = 'block';
                capturedSpins.forEach((spin, index) => {
                    const spinItemDiv = document.createElement('div');
                    spinItemDiv.className = 'captured-spin-item';
                    spinItemDiv.innerHTML = `<h4>Spin ${index + 1}: ${spin.type} (Count: ${spin.spinCount}) at ${spin.timestamp}</h4>`;

                    const newCanvas = document.createElement('canvas');
                    spinItemDiv.appendChild(newCanvas);
                    capturedSpinsContainer.appendChild(spinItemDiv);

                    const newCtx = newCanvas.getContext('2d');
                    // Set canvas dimensions explicitly for drawing captured graph
                    newCanvas.width = newCanvas.offsetWidth;
                    newCanvas.height = newCanvas.offsetHeight; // Use its own height

                    let lineColor, minValue, maxValue;
                    if (spin.type === 'Yaw') {
                        lineColor = '#27AE60';
                        minValue = 0;
                        maxValue = 360;
                    } else if (spin.type === 'Pitch') {
                        lineColor = '#3498DB';
                        minValue = -90;
                        maxValue = 90;
                    } else { // Roll
                        lineColor = '#F1C40F';
                        minValue = -90;
                        maxValue = 90;
                    }

                    // Animate drawing the captured spin graph
                    let animationStartTime;
                    const animationDuration = 1000; // 1 second animation

                    function animateCapturedGraph(currentTime) {
                        if (!animationStartTime) animationStartTime = currentTime;
                        const elapsedTime = currentTime - animationStartTime;
                        const progress = Math.min(elapsedTime / animationDuration, 1);

                        drawGraph(newCtx, spin.data, minValue, maxValue, lineColor, progress);

                        if (progress < 1) {
                            requestAnimationFrame(animateCapturedGraph);
                        }
                    }
                    requestAnimationFrame(animateCapturedGraph);
                });
            } else {
                showMessage('Monitoring stopped. No spins were detected during this session.', 'info');
            }
        }

        // --- Event Listeners for Buttons ---
        startButton.addEventListener('click', requestPermissionsAndStart);
        stopButton.addEventListener('click', stopMonitoring);

        // --- Initial Canvas Setup (Resizes canvas to match CSS size) ---
        function resizeCanvas() {
            // Resize live graphs
            yawGraphCanvas.width = yawGraphCanvas.offsetWidth;
            yawGraphCanvas.height = yawGraphCanvas.offsetHeight;
            pitchGraphCanvas.width = pitchGraphCanvas.offsetWidth;
            pitchGraphCanvas.height = pitchGraphCanvas.offsetHeight;
            rollGraphCanvas.width = rollGraphCanvas.offsetWidth;
            rollGraphCanvas.height = rollGraphCanvas.offsetHeight;

            // Redraw live graphs if monitoring is active
            if (isMonitoring) {
                 drawGraph(yawGraphCtx, historyAlpha, 0, 360, '#27AE60');
                 drawGraph(pitchGraphCtx, historyBeta, -90, 90, '#3498DB');
                 drawGraph(rollGraphCtx, historyGamma, -90, 90, '#F1C40F');
            } else {
                // Clear live canvases if not monitoring and they are resized
                yawGraphCtx.clearRect(0,0, yawGraphCanvas.width, yawGraphCanvas.height);
                pitchGraphCtx.clearRect(0,0, pitchGraphCanvas.width, pitchGraphCanvas.height);
                rollGraphCtx.clearRect(0,0, rollGraphCanvas.width, rollGraphCanvas.height);
            }
        }

        // Run resize on load and whenever window resizes
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);


        // Initial state setup on page load
        // Removed `updateDisplay()` from here as it relies on initial values
        // which might not be set until worker starts or sensorData is received.
        // The display will be updated once sensorData is first received.
        showMessage('Welcome to SpinSense! Press "Start Monitoring" to begin. You may be asked for motion sensor permissions.', 'info');
        startButton.disabled = false;
        stopButton.disabled = true;

    </script>
</body>
</html>
