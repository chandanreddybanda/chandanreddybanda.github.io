<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Accurate Spin Counter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    
    <style>
        /* CSS is embedded directly into the HTML file */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: white;
            overscroll-behavior-y: contain; /* Prevents pull-to-refresh interference */
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            color: white;
            transition: background-color 0.3s, transform 0.2s;
            border: none;
            cursor: pointer;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .spin-detected {
            animation: pulse-bright 0.6s ease-out;
        }

        @keyframes pulse-bright {
            0% {
                transform: scale(1);
                text-shadow: 0 0 5px rgba(255, 255, 255, 0);
            }
            50% {
                transform: scale(1.15);
                text-shadow: 0 0 20px rgba(34, 211, 238, 0.9); /* cyan-400 glow */
            }
            100% {
                transform: scale(1);
                text-shadow: 0 0 5px rgba(255, 255, 255, 0);
            }
        }

        #spin-gallery .spin-card {
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 0.5rem;
            padding: 0.75rem;
            text-align: center;
            border: 1px solid #374151; /* border-gray-700 */
        }

        #spin-gallery .spin-card canvas {
            width: 100%;
            height: auto;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body class="antialiased">

    <div id="app" class="container mx-auto p-4 max-w-lg">
        <header class="text-center my-4">
            <h1 class="text-4xl font-bold text-cyan-400">Accurate Spin Counter</h1>
            <p id="instructions" class="text-gray-400 mt-2 px-4">Press 'Start' and spin your phone to see the magic!</p>
        </header>

        <div id="spinCounters" class="grid grid-cols-3 gap-4 text-center my-8">
            <div>
                <h2 class="text-lg font-semibold text-gray-400">Yaw (Spin)</h2>
                <p id="yawCount" class="text-5xl font-bold text-white transition-transform duration-200">0</p>
            </div>
            <div>
                <h2 class="text-lg font-semibold text-gray-400">Pitch (Flip)</h2>
                <p id="pitchCount" class="text-5xl font-bold text-white transition-transform duration-200">0</p>
            </div>
            <div>
                <h2 class="text-lg font-semibold text-gray-400">Roll (Roll)</h2>
                <p id="rollCount" class="text-5xl font-bold text-white transition-transform duration-200">0</p>
            </div>
        </div>

        <div id="graphsContainer" class="my-6 space-y-4">
            <div>
                <label class="text-gray-400">Yaw (Z-axis)</label>
                <canvas id="yawCanvas" class="w-full h-24 bg-gray-800 rounded-lg"></canvas>
            </div>
            <div>
                <label class="text-gray-400">Pitch (X-axis)</label>
                <canvas id="pitchCanvas" class="w-full h-24 bg-gray-800 rounded-lg"></canvas>
            </div>
            <div>
                <label class="text-gray-400">Roll (Y-axis)</label>
                <canvas id="rollCanvas" class="w-full h-24 bg-gray-800 rounded-lg"></canvas>
            </div>
        </div>
        
        <div id="controls" class="flex justify-center gap-4 my-6">
            <button id="startBtn" class="btn bg-green-500 hover:bg-green-600">Start Monitoring</button>
            <button id="stopBtn" class="btn bg-red-500 hover:bg-red-600 hidden">Stop Monitoring</button>
        </div>

        <div id="results" class="hidden">
            <div id="capturedSpinsContainer" class="my-6">
                <h3 class="text-2xl font-bold text-center text-cyan-400 mb-4">Captured Moments</h3>
                <div id="spin-gallery" class="grid grid-cols-2 md:grid-cols-3 gap-4"></div>
            </div>
            <div class="text-center">
                <button id="shareBtn" class="btn bg-blue-500 hover:bg-blue-600">Share Results</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // UI Elements
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const shareBtn = document.getElementById('shareBtn');
            const instructions = document.getElementById('instructions');
            const resultsSection = document.getElementById('results');
            const capturedSpinsContainer = document.getElementById('spin-gallery');

            const uiCounts = {
                yaw: document.getElementById('yawCount'),
                pitch: document.getElementById('pitchCount'),
                roll: document.getElementById('rollCount'),
            };

            const canvases = {
                yaw: document.getElementById('yawCanvas'),
                pitch: document.getElementById('pitchCanvas'),
                roll: document.getElementById('rollCanvas'),
            };
            
            const contexts = {
                yaw: canvases.yaw.getContext('2d'),
                pitch: canvases.pitch.getContext('2d'),
                roll: canvases.roll.getContext('2d'),
            };

            // State Variables
            let monitoring = false;
            let history = { yaw: [], pitch: [], roll: [] };
            const historyLength = 100;
            let spinProcessor;

            const resetSpinProcessor = () => {
                spinProcessor = {
                    yaw: { cumulativeAngle: 0, lastAngle: null, spins: 0 },
                    pitch: { lastValue: 0, crossedHigh: false, crossedLow: false, spins: 0 },
                    roll: { lastValue: 0, crossedHigh: false, crossedLow: false, spins: 0 }
                };
            };
            
            // --- CORE LOGIC ---

            const handleOrientation = (event) => {
                if (!monitoring) return;

                const { alpha, beta, gamma } = event;
                if (alpha === null || beta === null || gamma === null) return;
                
                processYaw(alpha);
                processPitch(beta);
                processRoll(gamma);

                updateLiveGraph('yaw', alpha, 0, 360);
                updateLiveGraph('pitch', beta, -180, 180);
                updateLiveGraph('roll', gamma, -90, 90);
            };

            // ACCURATE YAW SPIN CALCULATION (Cumulative Method)
            const processYaw = (currentAngle) => {
                const state = spinProcessor.yaw;
                if (state.lastAngle === null) {
                    state.lastAngle = currentAngle;
                    return;
                }

                let delta = currentAngle - state.lastAngle;

                // Handle wrap-around from 359 to 1 degree and vice-versa
                if (delta > 180) delta -= 360;
                if (delta < -180) delta += 360;

                state.cumulativeAngle += delta;
                state.lastAngle = currentAngle;
                
                const currentSpins = Math.floor(Math.abs(state.cumulativeAngle) / 360);

                if (currentSpins > state.spins) {
                    state.spins = currentSpins;
                    triggerSpinUpdate('yaw', state.spins);
                }
            };
            
            // ACCURATE PITCH/ROLL CALCULATION (Peak Detection for Flips/Rolls)
            const processPeakDetection = (axis, currentValue, threshold) => {
                const state = spinProcessor[axis];
                
                // Check for crossing the high and low thresholds
                if (currentValue > threshold) state.crossedHigh = true;
                if (currentValue < -threshold) state.crossedLow = true;
                
                // A full "flip" or "roll" is complete when we return to near-zero after hitting both peaks
                if (state.crossedHigh && state.crossedLow && Math.abs(currentValue) < (threshold / 2)) {
                    state.spins++;
                    triggerSpinUpdate(axis, state.spins);
                    // Reset for the next spin
                    state.crossedHigh = false;
                    state.crossedLow = false;
                }
                state.lastValue = currentValue;
            };

            const processPitch = (currentValue) => processPeakDetection('pitch', currentValue, 75); // 75 degree threshold for a flip
            const processRoll = (currentValue) => processPeakDetection('roll', currentValue, 75); // 75 degree threshold for a roll

            const triggerSpinUpdate = (axis, count) => {
                uiCounts[axis].textContent = count;
                uiCounts[axis].classList.add('spin-detected');
                setTimeout(() => uiCounts[axis].classList.remove('spin-detected'), 600);
                
                captureSpin(axis, count, [...history[axis]]);

                const totalSpins = spinProcessor.yaw.spins + spinProcessor.pitch.spins + spinProcessor.roll.spins;
                if (totalSpins > 0 && totalSpins % 5 === 0) triggerConfetti();
            };

            // --- UI & DRAWING ---

            const setupCanvas = (canvas, context) => {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                context.scale(dpr, dpr);
            };

            const resetAll = () => {
                monitoring = false;
                resetSpinProcessor();
                history = { yaw: [], pitch: [], roll: [] };
                
                Object.values(uiCounts).forEach(el => el.textContent = '0');
                
                Object.entries(contexts).forEach(([key, ctx]) => {
                    const canvas = canvases[key];
                    const rect = canvas.getBoundingClientRect();
                    ctx.clearRect(0, 0, rect.width, rect.height);
                });
                
                capturedSpinsContainer.innerHTML = '';
                resultsSection.classList.add('hidden');
                stopBtn.classList.add('hidden');
                startBtn.classList.remove('hidden');
            };
            
            const startMonitoring = () => {
                resetAll();
                monitoring = true;
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                instructions.textContent = "Spin away! Let's see what you've got.";
                window.addEventListener('deviceorientation', handleOrientation);
            };
            
            const stopMonitoring = () => {
                monitoring = false;
                window.removeEventListener('deviceorientation', handleOrientation);
                stopBtn.classList.add('hidden');
                startBtn.classList.remove('hidden');
                
                const totalSpins = spinProcessor.yaw.spins + spinProcessor.pitch.spins + spinProcessor.roll.spins;
                if (totalSpins > 0) {
                    resultsSection.classList.remove('hidden');
                }
                instructions.textContent = "Great job! Press 'Start' to go again.";
            };

            const updateLiveGraph = (axis, value, min, max) => {
                const data = history[axis];
                data.push(value);
                if (data.length > historyLength) data.shift();

                const context = contexts[axis];
                const canvas = canvases[axis];
                const { width, height } = canvas.getBoundingClientRect();
                
                context.clearRect(0, 0, width, height);
                context.beginPath();
                context.lineWidth = 2;
                context.strokeStyle = '#22d3ee'; // cyan-400
                
                data.forEach((point, i) => {
                    const x = (i / (historyLength - 1)) * width;
                    const y = height - ((point - min) / (max - min)) * height;
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                });
                context.stroke();
            };
            
            const captureSpin = (axis, count, data) => {
                const card = document.createElement('div');
                card.className = 'spin-card';
                const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                card.innerHTML = `
                    <p class="font-semibold text-cyan-400">${axis.charAt(0).toUpperCase() + axis.slice(1)} #${count}</p>
                    <p class="text-xs text-gray-500">${timestamp}</p>
                `;
                capturedSpinsContainer.appendChild(card);
            };

            const triggerConfetti = () => {
                if (window.confetti) confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }});
            };

            // --- EVENT LISTENERS ---

            startBtn.addEventListener('click', () => {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(state => {
                            if (state === 'granted') startMonitoring();
                            else alert('Permission to access device orientation was denied.');
                        }).catch(console.error);
                } else {
                    startMonitoring();
                }
            });

            stopBtn.addEventListener('click', stopMonitoring);
            
            shareBtn.addEventListener('click', () => {
                const totalSpins = spinProcessor.yaw.spins + spinProcessor.pitch.spins + spinProcessor.roll.spins;
                const shareData = {
                    title: 'Spin Counter Results',
                    text: `I did ${totalSpins} total spins! (Spins: ${spinProcessor.yaw.spins}, Flips: ${spinProcessor.pitch.spins}, Rolls: ${spinProcessor.roll.spins}). Can you beat me?`,
                    url: window.location.href
                };

                if (navigator.share) {
                    navigator.share(shareData).catch(console.error);
                } else {
                    alert('Share functionality not supported on this browser.');
                }
            });
            
            // Initial Setup
            Object.values(canvases).forEach((canvas, i) => setupCanvas(canvas, Object.values(contexts)[i]));
            resetAll();
        });
    </script>
</body>
</html>
